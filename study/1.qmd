### stat1

```{python}
import numpy as np
import matplotlib.pyplot as plt
```

```{python}
np.random.rand(1)
```

랜덤 상수 하나 생성 (0 ~ 1)

```{python}
def Y(num, p):
  x = np.random.rand(num)
  return np.where(x < p, 1, 0)

Y(10, 0.5)
```

베르누이 확률 변수 p 만드는 함수

```{python}
def Z():
  x = np.random.rand(1)
  return np.where(x < 0.2, 0, np.where(x < 0.7, 1, 2))

Z()[0]
```

가질 수 있는 값: 0, 1, 2

각각의 확률: 20%, 50%, 30%

`np.where(condition, [x, y, ]/)`: 조건에 따라 선택된 요소를 반환


### stat2

```{python}
data = np.random.rand(10)
plt.hist(data, bins = 30, alpha = 0.7, color = "blue")
plt.title('Histogram of Numpy Vector')
plt.xlabel('Value')
plt.ylabel('Frequency')
plt.grid(True)
plt.show()
```

`matplotlib.pyplot.hist(x, bins, range, density, weights, cumulativee, bottom, histtype='bar', align='mid', orientation='vertical', rwidth, log, color, label, stacked, *, data, **kwargs)`

`bins`: 가로축 구간의 개수

`alpha`: 투명도

```{python}
print(np.random.rand(50000).reshape(-1, 5))

mean = np.random.rand(50000).reshape(-1, 5).mean(axis = 1)
plt.hist(mean, color = 'red')
plt.show()
```

5개 뽑아서 10000번 반복하고 그 표본평균을 히스토그램으로 쌓아서 경향 파악

5개를 10000번 반복하는 걸 50000개 뽑는 걸로 합치고, 구분하기 위해 `reshape(row, column)`

```{python}
np.unique((np.arange(33) - 16) **2)
```

`numpy.unique(ar)`: 중복된 값을 제거

```{python}
x = np.arange(4)
pro_x = np.array([1/6, 2/6, 2/6, 1/6])

Ex = sum(x * pro_x) # 기댓값
Exx = sum(x**2 * pro_x) # E[X^2]

# Var(X) = E[X^2] - (E[X])^2
Exx - Ex**2

# or E[(X - E[X])**2]
sum((x - Ex)**2 * pro_x)
```

X = 0, 1, 2, 3이고 확률이 1/6, 2/6, 2/6, 1/6일 때 분산

```{python}
x = np.arange(99)
arr = np.concatenate((np.arange(1, 50), np.arange(50, 0, -1)))
pro_x = arr / 2500

Ex = sum(x * pro_x)
Exx = sum(x**2 * pro_x)
Exx - Ex**2
```

0에서부터 98까지의 정수, 1/2500, 2/2500, 3/2500, ... 50/2500, ... 1/2500일 때 분산은?

`np.concatenate()`: 기존 축을 따라 배열 시퀀스를 연결 (`axis=0`이면 행(상하), `axis=1`이면 열 방향(좌우))

